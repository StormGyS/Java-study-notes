二:java语言基础组成

  1.关键字:被java语言赋予了特殊含义的单词,都小写.
  
  (1)用来定义数据类型:class,interface,byte,short,int,long,float,double,char,boolean,void.
  (2)用来定义数据类型的值:true,false,null.
  (3)用来定义流程控制:if,else,switch,case,default,while,do,for,break,continue,return.
  (4)用来定义访问权限的修饰符:public,private,protected.
  (5)用来定义类,函数,变量的修饰符:abstract,final,static,synchronized.
  (6)用来定义类与类之间的关系:extends,implements.
  (7)用来定义建立实例及引用实例和判断实例:new,this,super,instanceof.
  (8)用来异常处理:try,catch,finally,throw,throws.
  (9)用来包:package,import.
  (10)其他修饰符:native,strictfp,transient,volatile,assert.
  
  2.标识符:程序中自定义的一些名称,由字母,数字0~9和_与$组成,数字不可以开头,不能使用关键字,严格区分大小写,要有意义.
  
  (1)包名:多单词组成时都小写,xxxyyyzzz.
  (2)类名接口名:多单词组成时,所有单词首字母大写,XxxYyyZzz.
  (3)变量名和函数名:多单词组成时,第一个单词首字母小写,其他大写,xxxYyyZzz.
  (4)常量名:所有字母都大写,多单词时用下划线连接,XXX_YYY_ZZZ.
  
  3.注释://  /**/  /***/(文档注释):注释内容可以被jdk提供的工具javadoc所解析,生成一套以网页文件形式体现的该程序的说明文档.
  
  /**
  这是我的Hello World程序.
  @author GyS
  */
  public class Demo
  {
     /*
     这是主函数,程序的入口.
     它可以保证程序的独立运行.
     */
     public static void main(String[] args)
     {
           //输出Hello World!
           System.out.println("Hello World");
     }
  }
  
  4.常量与变量
  
  (1)常量:不能改变的数值.分类有整数常量;小数常量;布尔型常量,数值有true和false;字符常量将一个数字字母符号用单引号''标识;字符串常量将一个或者多个字符
  用双引号""标识;null常量只有一个数值就是null.
     对于整数,有三种表现形式:十进制,0~9,满10进1;八进制,0~7,满8进1,用0开头表示;十六进制,0~9,A~F,满16进1,用0x开头表示.还有二进制,计算机中表示数据就用二进制,为什么用十,八,十六进制,就是为了更方便的表示一个整数,十进制60,和十六进制0x3c输出都是整数60.
  (i)整数6用int定义,32bit,4个byte,前面都补0,那么负整数-6就是正整数6的取反加1.
  (2)变量:数值可变,内存中开辟多少位的二进制来存变量的数值由数据类型决定.
  (i)基本数据类型:数值型(又分整数类型[byte,short,int,long]和浮点类型[float,double])与字符型(char)及布尔型(boolean).
  (ii)引用数据类型:类(class),接口(interface)及数组([]).
  整数默认int,小数默认double.所以要加L与f.
  (iii)强制类型转换,byte b=3,b=b+2,打印b,会报错,为什么?因为b是byte,而2是int,计算b+2,会将b提升为int型再与2计算,为int(32bit),赋给b(8bit),导致丢失精度,故报错.而(byte)(b+2),则将b+2的值(int)强制转换为byte,即干掉前三个格子,留最后一个格子.应用就是可以把小数保留整数部分吧;打印字符a:System.out.println('a'),输出a;那么System.out.println('a'+1),因为字符a在ASCii编码表对应数值97,所以输出数值98.则打印c,用强制类型转换有System.out.println((char)('a'+2)),输出字符c.
  
  5.运算符
  
  (1)算数运算符: 正号(+)  负号(-)  加减乘除(+-*/)  取模(取余数%)  自增(++)  自减(--)  字符串相加(+)
  eg:(i)5%5为0,1%5为1,5%1为0;-1%5为-1,1%(-5)为1,符号取决于被模数. (ii)a=2,b=++a,则b=3,a=3; a=2,b=a++,则b=2,a=3; a=2,b=--a,则a=1,b=1; a=2,b=a--,则a=1,b=2. (iii)"he"+"llo"为hello. (iv)int i=4567,i=i/1000*1000,为4000吧,不为4567了,因为4567/1000为4.567,而为int,结果为4,而4*1000即为4000,要注意.
     字符串数据与所有数据使用+号相连接,结果为字符串.eg:System.out.println("a="+a+",b="+b);输出a=4,b=4.
     转义字符:通过\转变后面字符的含义. \n:换行 \b:退格,相当于backspace \r:按下回车键(注意Windows系统下回车符用两个表示\r\n) \t:制表符,相当于Tab键 \":打印" \':打印' char ch ='你';//可以,因为char类型为2byte,而一个汉字也为2byte. println中的ln就是换行,直接为print则不换行.
  (2)赋值运算符:(i)int i=4; //= += -= *= /= eg:i+=4;//i=i+4,以此类推. (ii)short s=4; s=s+4;//编译失败,损失精度. s+=4;//编译通过,两边会自动进行强制转换.
  (3)比较运算符:== != < > <= >= instanceof:检查是否是类的对象,eg:"hello" instanceof String //为true  注意:就是比较运算符的结果都为boolean型,即结果为true或者false.
  (4)逻辑运算符:用来连接值为Boolean型的表达式. &(与):eg:a=4,a>3&a<6,结果为true,即一假则假. |(或):一真为真. !(非):eg:!true即为false. ^(异或):相同为0(false),相异为1(true). &&(与[短路]):左边为false,结束判断,为false. ||(或[短路]):左边为真,结束判断,为true.
     注意:&&和||通常用在判断语句中,是为了提高判断效率,利用他的短路,不用&,|是因为两边都要判断,这三个也可用来二进制运算,eg:3&5.
         !也叫一元运算符.
  (5)位运算符:<<(左移),eg:3<<2值为12,即左移n位,相当于*二的n次幂,记角朝哪边就往哪边移. >>(右移):eg:6>>2值为1,记右移n位,相当于/二的n次幂. 注意:3为int,存为32bit,左移2位时,就是干掉首2位,末尾补0;而右移2位时,干掉末尾2位,首2位补0还是1取决于原来的二进制首位是0还是1,0则补0,1则补1. >>>(无符号右移):不管,就是补0. &(与运算),|(或运算)和^(异或运算),位运算都是对二进制进行运算,方法同上. ~(反码,即取反):eg:~6为-7?why?因为6为0...110(32bit),取反为1...001,他的十进制表示为-7,因为-6由6取反加1得来,那么反着来,对1...001减1取反则为0...111,原来最高位为1,负数,所以为7->(-7).
  应用(i):7^4^4为7,结论:一个数与同一个数异或两次,值不变.可用来做加密使用,给定一个数,二进制存在内存里,对他进行一次某个数的异或,即加密,解密就是再异或该数.
     (ii):高效计算2*8,即为2<<3. n=3,m=8,交换n,m的值,第一种定义temp变量;第二种用+运算符,即n=n+m,m=n-m,n=n-m;第三种用异或,n=n^m,m=n^m//m=(n^m)^m,n=n^m//n=n^(n^m).
     (iii)&和>>>运算符的使用:eg:6,0...0110(32bit),要想获取6的二进制的有效位,设每次获取4位,那是不是就&上15(0...1111),对吧;获取三位,&7.那么低4位获取了,就用>>>,右移4位,获取次低4位即可.不用>>,因为若为负数,那用>>每次高位补1,就挂了,移不完了.
     (iv)如何将数字转变为十六进制,eg:12,因为12在十六进制中为C,想到字符A,那么C就为'A'加2,又因为十六进制0~9,A~F,那么12(C)-10(A)=2,所以得出C=(char)(12-10+'A');//A对应十六进制的10,ASCii中数值为65.
   (6)三元运算符:格式 (条件表达式)?表达式1:表达式2; eg:int x=3,y=4,z; z=(x>y)?x:y;//z为4.
   
6.程序流程控制

(1)判断结构  if语句:三种格式 
   (i)if(条件表达式)
      {
      执行语句;
      } 
   (ii)if(条件表达式)
       {
       执行语句;
       }
       else
       {
       执行语句;
       }
   (iii)if(条件表达式1)       //当满足任一条件时,执行该语句,结束,不管下面语句是否成立,都不执行.
        {
        执行语句1;
        }
        else if(条件表达式2)
        {
        执行语句2;
        }
        ...
        else
        {
        执行语句n;
        }
    应用:Demo0:4.定义一个月份,判断他是哪个季节.3~5春季,6~8夏季,9~11秋季,12-1-2为冬季.
 (2)选择结构:  swith语句
    格式: switch(表达式)
          {
          case 取值1:
               执行语句;
               break;
          case 取值2:
               执行语句;
               break;
          ......
          default
               执行语句;
               break;
          }
     注意:switch语句的四个特点  (i)switch语句中的表达式,即选择的类型只能为byte,short,int或者char;  (ii)先执行第一个case语句,若都不匹配,则执行default语句,case语句与default语句没有顺序;  (iii)switch语句只有碰到break语句,就跳出switch,或者到结尾才执行结束;  (iv)如果case和default没有对应的break语句,那么即使执行完case(匹配成功)或者是default,仍然会在switch语句中继续执行(不管是否匹配了,都会执行),直到碰到break或者结尾才结束.
         switch语句中表达式可不是i>3之类的,这要记住.表达式只能是只能是整数类型(除long)和字符类型,用switch实现输出季节,int i=5,switch(i),case3,打印春季case4打印春季case5打印春季,这可以合并一下,即case 3: case 4: case 5: 打印春季(三个case,一个打印即可); 取值1(2或者...)只能是符合选择类型.
         if与switch可以互用,应用场景一般是如果判断的数据只有几个,且符合选择类型,建议用switch,效率较高;如果是判断区间和结果为boolean型,建议使用if.
  (3)循环结构: 三种语句
  (i)while语句  格式  while(条件表达式){循环体(执行语句);}  注意当使用i++;或者++i;他两是一样的,都是自增1,是单条语句,但是把他俩赋值给某个变量就不一样了.  Dos窗口下结束死循环 Ctrl+c.
  (ii)do...while语句  格式  do{循环体;}while(条件表达式);
  注:(i)与(ii)区别就是(ii)至少执行一次.
  (iii)for语句  格式  for(初始化表达式;循环条件表达式;循环后的操作表达式) {循环体;}  注意,使用for语句定义的初始化自增变量,作用域只在for语句中,不能被其他语句使用,比如说不能打印i自增结束循环时的值.注意变量的作用域.for语句结束后,i的内存就被释放了.所以说当只需要使用自增量,使用for(老外做的优化,节省内存),不用while语句.
  注意:for语句中的初始化表达式可以写外面,也可以是一条执行语句(别思维定式),对于循环条件表达式必须是布尔型,要有真假值;多执行语句用逗号隔开.
       最简单的无限循环语句: for(;;)//循环条件表达式默认为真{}  while(true){}
       写循环一定要明确哪些语句要循环,哪些不要循环,打印sum语句就不需要循环.
  应用:Demo0:5.求1加到10的和.
      Demo0:6.求1~100之间7的倍数的数的个数,并打印.
  注意:思想思想思想很重要,代码只是思想的字母表示.
  总结:(1)记住一个代码只能解决一个问题,记住一个思想就能解决一类问题.求1~100之间的数,即遍历,用for循环语句.
      (2)Demo0:5  累加思想:通过变量(eg:sum)来记住记住记住每次循环操作后的结果,通过循环,来进行累加动作.
      (3)Demo0:6  计数器思想:通过变量(eg:count)来记录记录记录住数据的状态变化(eg:被7蒸馍的数),也需要通过循环实现(自增).
  (iv)嵌套循环:  Demo0:6使用了for语句中嵌套了if语句  现在介绍forfor嵌套语句,形象点就是大圈套小圈.
          格式:
               for(;;)
               {
                  for(;;)
                  {
                  }
               }
          /*
          外循环控制行数,内循环控制每行的列数(即每行中的元素的个数);
          有个注意点就是内循环的输出打印语句"不要不要不要加ln",在外循环语句中使用System.out.println();//功能就是换行,即打印完列数后再换行.
          */
     应用:Demo0:7.打印下面图案
     (1)****
        ****
        ****
     (2)*****
        ****
        ***
        **
        *
    总结:不是规律的规律:  打印尖朝上,改变循环条件表达式,使其为外循环的(小于或等于)变量x;
                         打印尖朝下,改变初始化表达式,使其为外循环(等于)变量x.
         内循环的第一个表达式是不是区间左边啊,第二个表达式是不是区间的右边啊.左右区间可以改变为一个变量.
     (3)1
        12
        123
        1234
        12345
     (4)打印九九乘法表
        1*1=1
        1*2=2 2*2=4
        1*3=3 2*3=6 3*3=9
        ...
(4)其他控制流程语句
   break(跳出):应用在switch和loop语句中;
   continue(继续):应用在loop语句中.
   注:(i)这两个语句离开应用范围,存在没有意义;
      (ii)这两个语句单独存在是,下面不能有语句,因为执行不到.
      eg1:单独存在
           ...
           break/continue;  //不能输出打印
           System.out.println("hello");
      eg2:/*
          用continue控制循环,打印1到10的偶数
          部分代码如下
          */
          if(i%2==1)
             continue;
          System.out.println("i="+i);
       (iii)break跳出循环,即结束循环了;continue结束本次循环,继续下一次循环;
       (iv)标号的出现,可以让这两个语句指定作用范围
       eg:
          ...
          q: for(;;)  //给外循环起名叫q
             {
               w: for(;;)  //给内循环起名叫w
               {
               ...
               break q/w;(continue q/w;)  //指定跳出或者继续外(内)循环
               }
             }
  应用:(5)打印下面图案
      ----*
      ---* *
      --* * *
      -* * * *
      * * * * *
      /*
      1.需求:打印*号所组成的等腰三角形,其中短横线用于标识作用,最后结果仅仅只有三角形
      2.思路:
      (1)可以先分成两部分来做,一部分打印短横线,另一部分打印三角形.
      (2)5行,先打印短横线图形
      (3)在打印三角形
      3.步骤:
      (1)定义x,作为控制5行
      (2)定义y,控制短横线的列数
      (3)定义z,控制三角形的列数
      */
      
7.函数

 7.1函数的定义
  (1)函数(方法):定义在类中的具有特定功能的一段独立的小程序.
  (2)函数格式:
  修饰符 返回值类型 函数名(参数类型 形式参数1,参数类型 形式参数2,...)
  {
        执行语句;
        return 返回值;
  }
  Demo0:8.利用函数计算整数*3+5的值.
 7.2函数的特点
  (1)定义函数可以将功能代码进行封装;
  (2)功能进行了复用,提高了代码的复用性;
  (3)定义的函数只有被调用才会被执行(eg:main函数调用了getResult()函数,进行了计算);
  (4)当定义的函数无具体的返回值时,返回值类型为void,且return;可不写(eg:在main函数中只调用函数,即getResult(4);打印在getResult()函数中,retutn;可以省略.);
  (5)注意:函数只能调用函数,不能在函数中定义函数;
         定义函数时,函数的结果要返回给调用者,供调用者使用.
 7.3函数的应用  如何定义一个函数?  两个明确:
  (1)明确该功能的结果,即确定返回值类型;
  (2)明确在定义该功能过程中是否有未知参数进行运算,即确定形参类型和个数(eg:函数中我就打印一个字母,即形参为空,不写;返型为void,return;不写.)
  (3)注意:当定义的函数的返回值类型为void时,调用者不能输出打印;
          定义函数时,实现该函数的功能即可,至于返回值是是是交给调用者使用的,别私自在函数中定义处理结果的语句,比如说打印结果,这样不好.
     学习完定义一个函数后,那么前面的forfor嵌套语句等都可以封装在函数中,main函数调用即可.
 7.4函数的重载(overload)
  (1)重载:在同一个类中,允许一个及以上的相同的函数存在,但是必须必须必须要保证形参类型或者形参个数不同.
  (2)特点:与返回值类型无关,只与形参列表有关(调用者去找被调用者,用形参列表去区分相同的函数).
  (3)好处:方便于阅读(就是都想要去相加求和,用一个函数名add即可),有利于程序设计.
  (4)实例:int add(int x,int y)  int add(int x,int y,int z)  double add(double x,double y)
  (5)首先定义一个add函数求两个数的和,现在需求是求三个数的和,直接再写同一个add函数,去调用先前的两数的和再加z即可,return add(x,y)+z;
  (6)注意:int function(int x,double y,char z)和int function(int x,char z,double y)重载了,因为形式参数的顺序不同;
         int function(int x,double y,char z)和int function(int a,double b,char c)没有重载,因为与参数名称无关的;
         int function(int x,double y,char z)和double function(int a,double b,char c)没有重载,不能同时存在于同一个类中,与返回值类型无关.
         
8.数组

 8.1数组的定义
  (1)概念:同一种类型数据的集合,也叫作容器(装东西);
  (2)数组的好处:自动给数组中的元素从零开始编号,方便操作这些数据;
  (3)格式1: 元素类型 [] 数组名 = new 元素类型 [元素个数或数组长度];
       eg: int[] arr = new int[3]; //分析:arr是引用数据类型中的数组类型;赋值号左边,首先在内存的栈内存分配一个数组arr区域;
       赋值号右边,在堆内存中分配一个存整数类型的数组,假设起始地址为0x0097,那么数组名arr的值就为0x0097这个地址,再引用该堆内存地址下的数据元素;
       由于没有初始化,默认元素都为0;double默认0.0;float默认0.0f;boolean默认false.
           arr[0]=56;//0x0097这个地址放数据56.
     格式2: 元素类型[] 数组名 = new 元素类型[]{元素1,元素2,...};
       eg: int[] arr = new int[]{1,3,5,7};
           int[] arr ={1,3,5,7};
     当然别人写 int arr[]=new int[2]; //也可以
     注意: arr=null; //该数组没有任何地址指向了,,不在指向堆内存首地址了,后续无法操作数组元素了.
           System.out.println("arr["+0+"]="+arr[0]); //打印数组第一个元素,不能写成"arr[0]="+arr[0],要注意一下.
           System.out.println(arr);//打印输出数组的首地址.
      /*
      数组的操作:
      1.获取数组中的元素,通常采用遍历,即一个for循环 eg:for(int i=0;i<arr.length;i++),打印arr[i]; //i为数组下标
      2.数组中有一个属性可以直接获取到数组元素的个数: 数组名.length 这个属性很重要,比如可以拿来做判断,用于条件表达式中 eg: if(i!=arr.length-1)
      打印arr[i]和逗号;否则打印arr[i];//打印逗号是为了隔开数据元素.
      3.函数调用数组: function(arr);
      4.数组作为形参: function(int[] arr)
      */
      应用:(1)获取一个数组的最大值和最小值?
      第一种方法:直接定义一个max(min),初始化为数组的第一个元素,再分别比较;  max<arr[i],max=arr[i],return max;
      第二种方法:定义max(min)=0;再利用下标比较  arr[max]<arr[i],max=i,return arr[max].
      Demo0:9.对数组[5,1,6,4,2,8,9]进行排序?
      /*
      第一种方式:
      1.需求:排序
      选择排序思想:先拿arr[0]元素依次与arr[1]~arr[arr.length-1]进行比较,如果arr[0]<(或者>)arr[i],那么进行交换,否则不交换,以此类推,可以考虑到
      最后一个元素不需要交换.
      2.思路:
        第一次第一个元素分别与(假设元素长度为n)后n-1个元素比较;第二次第二个元素分别与后n-2个元素比较,以此类推,是不是类比第一行打印5个*,第二行打
      印4个*,...,是不是尖朝下三角形啊,哦啦,forfor嵌套,且改变左区间(初始化表达式),即y=x.
      */  
      /*
      第二种方式:
      1.需求:排序
      冒泡排序思想:每次将相邻的两个元素进行比较,如果符合条件就进行交换.
      2.思路:
        假设有5,1,6,4,2,8,9;第一趟:5与1比较,交换后为1,5;5与6比较,不交换为1,5,6,...第一趟结束后为1,5,4,2,6,,8,9;第二趟:注意到最(大/小)值到达
      末尾,即9不用在比较了,然后1与5比较,不交换,5与4比较交换,所以第二趟结束为1,4,2,5,6,8,9;以此类推,每i趟只要比较到arr[arr.length-i-1]这个元素
      (i从0开始,少取几个数,就能得出arr.length-i-1这个式子)
      */
      排序方式最快的是希尔排序.
      选择与冒泡排序的基本格式:
      for(int x=0;x<arr.length;x++)
      {
         for(int y=0;y<arr.length;y++)
         {
         }
      }
      注意:不管是选择排序还是冒泡排序,是不是都要进行交换元素位置,将交换操作封装到函数中.
      public static void swap(int[] arr, int a,int b) //只是交换为止,无返回值为void,因为是交换数组中的两个元素,所以要传数组参数,交换两元素
                                                     //要传两个下标
      {
      int temp=arr[a];
      arr[a]=arr[b];
      arr[b]=temp;
      }
      在两个内循环中调用swap(),即swap(arr,x,y);  swap(arr,y,y+1);
      前面学习了数组的获取和排序操作,接下来学习又一操作:
      /*
      数组的查找操作
      1.普通查找,在数组中找一元素的位置,返回下标(位置).
      public static int getIndex(int[] arr,int key) //返回下标为int,在数组中,要传数组形参,查找元素,要传元素形参
      {
      for{int i=0;i<arr.length;i++} //先遍历整个数组
      {
             if(arr[i]==key) //zhaodaoyuansu
             return i; //返回下标
      }
      return -1; //没找到,默认返回-1 
      }
      2.折半查找:效率高,但是前提必须必须必须是一个有序数组.
      思想:
      方法(1)每次利用折中的元素与要查找的元素进行比较,如果相等则返回该中间元素的下标;如果不等则移动
      某一端的下标,继续做折中比较;没有找到该元素的条件是左端下标大于右端下标或者右端小标小于左端下标.
      方法(2)上面的方法循环的条件是折中元素是否等于查找的数,当min>max,循环结束.现在考虑循环条件min<=max就一直循环,判断折中元素是否相等;相等就返回
      mid;不等就改变左或右下标,再求mid的值,继续做循环;否则就是没找到,返回-1.
      */
      Demo0:10.对数组[2,4,5,7,19,32,45]进行查找.
      思考:现在要对上面数组插入数字8,仍保持有序.
      任然利用折半查找,去找数字8的下标,用方法(2),假如数组有元素8,那么返回下标4,将4位置以后的元素顺延,插入数据8;如果没有元素8,原程序返回-1,
      在草稿纸上演算当返回-1时,即min>max,此时min=4,max=3,刚好min=4就是要插入数据的位置,那么就可将return -1;改为return min;//就是数据要插入
      的位置.
      练习:
      1.进制的转换
      eg1:将十进制转变为二进制: 6?
      /*
      1.需求:十->二
      2.思路:取余,拿6%2,打印余数;再拿6/2的商再模2后打印,直到商为0.
      部分代码:
      public static void toBin(int num)
      {while(num>0) {System.out.println(6%2); num=num/2;}}
      */
      eg2:将十进制转变为十六进制: 60?
      /*
      1.需求:十->十六
      2.思路:
        方法(1)我们知道十进制存在内存中为二进制,有32bit,60为0...0011-1100,十六进制对应每4位,所以先让60&15,取出末尾4位存在temp中,判断如果temp大于         9,做数字转化为字母操作;否则不变;再向右移4位,以此类推,循环是在移8次结束.
      public static void toHex(int num)
      {                                                               /*StringBuffer sb=new StringBuffer();//新建一个对象*/
           for(int i=0;i<8;i++)
           {                                                       
                  int temp=num&15;                                                       
                  if(temp>9)
                        System.out.println((char)temp-10+"A");       /*sb.append((char)temp-10+"A");//用容器提供的append()方法往里装*/
                  else 
                        System.out.println(temp);                    /*sb.append(temp);*/
                  num=num>>>4;       
           }
                                                              /*System.out.println(sb.reverse());//利用reverse方法打印正的十六进制*/
      }
         方法(2):对于方法(1),当取出的数超出9,就要减去基数10(对应"A")加上"A",对吧.现在换种方法:
         查表法:将所有数据临时存放在一个表中,建立对应的关系.
               就是建立一个字符数组,当num&15得出temp时,打印 字符数组名[temp]即可,不用再做判断了.
         注:在数组中,常常定义一个指针,作为首下标或末尾下标来使用 格式: int pos=0; int pos=arr.length-1;
            倒着打印 for(int i=arr.length-1;i>=0;i--) {System.out.println(arr[i]+" ");}
         */       
         综合应用:Demo0:11.利用查表法分别定义函数实现10->2,10->8,10->16的转化.
         /*
         思路:建立一个表,用来存储二,八和十六进制数;在建立一个表,用来存储转化的元素;转化封装成一个复用函数,三个函数可以分别调用这个转化函数.
         */
 8.5数组中的数组   二维数组[][]
  (1)格式1: int[][] arr=new int[3][2]; //定义了一个名称为arr的二维数组;二维数组里有三个一维数组;每一个一维数组里有两个元素;一维数组的名称
            //分别为arr[0],arr[1],arr[2];给第一个数组下标为1的位置赋值78,为arr[0][1]=78;
  (2)格式2: int[][] arr=new int[3][]; //二维数组里有三个一维数组;每个一维数组都是默认初始化值为null,即打印arr[0],输出null;由于一维数组的
            //长度不一,须分别赋值:arr[0]=new int[3];arr[1]=new int[1];arr[2]=new int[2];
     注:    int[][] arr={{1,2,3},{4},{5,6}}; //定义二维数组,里有三个一维数组,都已初始化了.
  (3)对于一维数组采用for循环进行遍历,而二维数组则采用forfor嵌套循环遍历,外循环x控制二维数组的行,即一维数组名;内循环y则控制每个一维数组的列,用
     arr[x][y]查询数据元素.
     
  /*
  练习:
  (1)int[] x;int x[];//对  (2)int[][] y;int[] y [];int y[][];//对  (3)int[] x,y[];//x是一维数组,y是二维数组  (4)x[0]=y;//错
  (5)y[0]=x;//对  (6)y[0][0]=x;//错  (7)x[0][0]=y;//错  (8)y[0][0]=x[0];//对  (9)x=y;//错
  */
                     
