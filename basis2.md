7.函数
 7.1函数的定义
  (1)函数(方法):定义在类中的具有特定功能的一段独立的小程序.
  (2)函数格式:
  修饰符 返回值类型 函数名(参数类型 形式参数1,参数类型 形式参数2,...)
  {
        执行语句;
        return 返回值;
  }
  Demo0:8.利用函数计算整数*3+5的值.
 7.2函数的特点
  (1)定义函数可以将功能代码进行封装;
  (2)功能进行了复用,提高了代码的复用性;
  (3)定义的函数只有被调用才会被执行(eg:main函数调用了getResult()函数,进行了计算);
  (4)当定义的函数无具体的返回值时,返回值类型为void,且return;可不写(eg:在main函数中只调用函数,即getResult(4);打印在getResult()函数中,retutn;可以省略.);
  (5)注意:函数只能调用函数,不能在函数中定义函数;
         定义函数时,函数的结果要返回给调用者,供调用者使用.
 7.3函数的应用  如何定义一个函数?  两个明确:
  (1)明确该功能的结果,即确定返回值类型;
  (2)明确在定义该功能过程中是否有未知参数进行运算,即确定形参类型和个数(eg:函数中我就打印一个字母,即形参为空,不写;返型为void,return;不写.)
  (3)注意:当定义的函数的返回值类型为void时,调用者不能输出打印;
          定义函数时,实现该函数的功能即可,至于返回值是是是交给调用者使用的,别私自在函数中定义处理结果的语句,比如说打印结果,这样不好.
     学习完定义一个函数后,那么前面的forfor嵌套语句等都可以封装在函数中,main函数调用即可.
 7.4函数的重载(overload)
  (1)重载:在同一个类中,允许一个及以上的相同的函数存在,但是必须必须必须要保证形参类型或者形参个数不同.
  (2)特点:与返回值类型无关,只与形参列表有关(调用者去找被调用者,用形参列表去区分相同的函数).
  (3)好处:方便于阅读(就是都想要去相加求和,用一个函数名add即可),有利于程序设计.
  (4)实例:int add(int x,int y)  int add(int x,int y,int z)  double add(double x,double y)
  (5)首先定义一个add函数求两个数的和,现在需求是求三个数的和,直接再写同一个add函数,去调用先前的两数的和再加z即可,return add(x,y)+z;
  (6)注意:int function(int x,double y,char z)和int function(int x,char z,double y)重载了,因为形式参数的顺序不同;
         int function(int x,double y,char z)和int function(int a,double b,char c)没有重载,因为与参数名称无关的;
         int function(int x,double y,char z)和double function(int a,double b,char c)没有重载,不能同时存在于同一个类中,与返回值类型无关.
8.数组
 8.1数组的定义
  (1)概念:同一种类型数据的集合,也叫作容器(装东西);
  (2)数组的好处:自动给数组中的元素从零开始编号,方便操作这些数据;
  (3)格式1: 元素类型 [] 数组名 = new 元素类型 [元素个数或数组长度];
       eg: int[] arr = new int[3]; //分析:arr是引用数据类型中的数组类型;赋值号左边,首先在内存的栈内存分配一个数组arr区域;
       赋值号右边,在堆内存中分配一个存整数类型的数组,假设起始地址为0x0097,那么数组名arr的值就为0x0097这个地址,再引用该堆内存地址下的数据元素;
       由于没有初始化,默认元素都为0;double默认0.0;float默认0.0f;boolean默认false.
           arr[0]=56;//0x0097这个地址放数据56.
     格式2: 元素类型[] 数组名 = new 元素类型[]{元素1,元素2,...};
       eg: int[] arr = new int[]{1,3,5,7};
           int[] arr ={1,3,5,7};
     当然别人写 int arr[]=new int[2]; //也可以
     注意: arr=null; //该数组没有任何地址指向了,,不在指向堆内存首地址了,后续无法操作数组元素了.
           System.out.println("arr["+0+"]="+arr[0]); //打印数组第一个元素,不能写成"arr[0]="+arr[0],要注意一下.
           System.out.println(arr);//打印输出数组的首地址.
      /*
      数组的操作:
      1.获取数组中的元素,通常采用遍历,即一个for循环 eg:for(int i=0;i<arr.length;i++),打印arr[i]; //i为数组下标
      2.数组中有一个属性可以直接获取到数组元素的个数: 数组名.length 这个属性很重要,比如可以拿来做判断,用于条件表达式中 eg: if(i!=arr.length-1)
      打印arr[i]和逗号;否则打印arr[i];//打印逗号是为了隔开数据元素.
      3.函数调用数组: function(arr);
      4.数组作为形参: function(int[] arr)
      */
      应用:(1)获取一个数组的最大值和最小值?
      第一种方法:直接定义一个max(min),初始化为数组的第一个元素,再分别比较;  max<arr[i],max=arr[i],return max;
      第二种方法:定义max(min)=0;再利用下标比较  arr[max]<arr[i],max=i,return arr[max].
      Demo0:9.对数组[5,1,6,4,2,8,9]进行排序?
      /*
      第一种方式:
      1.需求:排序
      选择排序思想:先拿arr[0]元素依次与arr[1]~arr[arr.length-1]进行比较,如果arr[0]<(或者>)arr[i],那么进行交换,否则不交换,以此类推,可以考虑到
      最后一个元素不需要交换.
      2.思路:
        第一次第一个元素分别与(假设元素长度为n)后n-1个元素比较;第二次第二个元素分别与后n-2个元素比较,以此类推,是不是类比第一行打印5个*,第二行打
      印4个*,...,是不是尖朝下三角形啊,哦啦,forfor嵌套,且改变左区间(初始化表达式),即y=x.
      */  
      /*
      第二种方式:
      1.需求:排序
      冒泡排序思想:每次将相邻的两个元素进行比较,如果符合条件就进行交换.
      2.思路:
        假设有5,1,6,4,2,8,9;第一趟:5与1比较,交换后为1,5;5与6比较,不交换为1,5,6,...第一趟结束后为1,5,4,2,6,,8,9;第二趟:注意到最(大/小)值到达
      末尾,即9不用在比较了,然后1与5比较,不交换,5与4比较交换,所以第二趟结束为1,4,2,5,6,8,9;以此类推,每i趟只要比较到arr[arr.length-i-1]这个元素
      (i从0开始,少取几个数,就能得出arr.length-i-1这个式子)
      */
      
      
      
      
     
     
       

  
  
  
