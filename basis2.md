7.函数
 7.1函数的定义
  (1)函数(方法):定义在类中的具有特定功能的一段独立的小程序.
  (2)函数格式:
  修饰符 返回值类型 函数名(参数类型 形式参数1,参数类型 形式参数2,...)
  {
        执行语句;
        return 返回值;
  }
  Demo0:8.利用函数计算整数*3+5的值.
 7.2函数的特点
  (1)定义函数可以将功能代码进行封装;
  (2)功能进行了复用,提高了代码的复用性;
  (3)定义的函数只有被调用才会被执行(eg:main函数调用了getResult()函数,进行了计算);
  (4)当定义的函数无具体的返回值时,返回值类型为void,且return;可不写(eg:在main函数中只调用函数,即getResult(4);打印在getResult()函数中,retutn;可以省略.);
  (5)注意:函数只能调用函数,不能在函数中定义函数;
         定义函数时,函数的结果要返回给调用者,供调用者使用.
 7.3函数的应用  如何定义一个函数?  两个明确:
  (1)明确该功能的结果,即确定返回值类型;
  (2)明确在定义该功能过程中是否有未知参数进行运算,即确定形参类型和个数(eg:函数中我就打印一个字母,即形参为空,不写;返型为void,return;不写.)
  (3)注意:当定义的函数的返回值类型为void时,调用者不能输出打印;
          定义函数时,实现该函数的功能即可,至于返回值是是是交给调用者使用的,别私自在函数中定义处理结果的语句,比如说打印结果,这样不好.
     学习完定义一个函数后,那么前面的forfor嵌套语句等都可以封装在函数中,main函数调用即可.
 7.4函数的重载(overload)
  (1)重载:在同一个类中,允许一个及以上的相同的函数存在,但是必须必须必须要保证形参类型或者形参个数不同.
  (2)特点:与返回值类型无关,只与形参列表有关(调用者去找被调用者,用形参列表去区分相同的函数).
  (3)好处:方便于阅读(就是都想要去相加求和,用一个函数名add即可),有利于程序设计.
  (4)实例:int add(int x,int y)  int add(int x,int y,int z)  double add(double x,double y)
  (5)首先定义一个add函数求两个数的和,现在需求是求三个数的和,直接再写同一个add函数,去调用先前的两数的和再加z即可,return add(x,y)+z;
  (6)注意:int function(int x,double y,char z)和int function(int x,char z,double y)重载了,因为形式参数的顺序不同;
         int function(int x,double y,char z)和int function(int a,double b,char c)没有重载,因为与参数名称无关的;
         int function(int x,double y,char z)和double function(int a,double b,char c)没有重载,不能同时存在于同一个类中,与返回值类型无关.
8.数组
 8.1数组的定义
  (1)概念:同一种类型数据的集合,也叫作容器(装东西);
  (2)数组的好处:自动给数组中的元素从零开始编号,方便操作这些数据;
  (3)格式1: 元素类型 [] 数组名 = new 元素类型 [元素个数或数组长度];
       eg: int[] arr = new int[3]; //分析:arr是引用数据类型中的数组类型;赋值号左边,首先在内存的栈内存分配一个数组arr区域;
       赋值号右边,在堆内存中分配一个存整数类型的数组,假设起始地址为0x0097,那么数组名arr的值就为0x0097这个地址,再引用该堆内存地址下的数据元素;
       由于没有初始化,默认元素都为0;double默认0.0;float默认0.0f;boolean默认false.
           arr[0]=56;//0x0097这个地址放数据56.
     格式2: 元素类型[] 数组名 = new 元素类型[]{元素1,元素2,...};
       eg: int[] arr = new int[]{1,3,5,7};
           int[] arr ={1,3,5,7};
     当然别人写 int arr[]=new int[2]; //也可以
     注意: arr=null; //该数组没有任何地址指向了,,不在指向堆内存首地址了,后续无法操作数组元素了.
           System.out.println("arr["+0+"]="+arr[0]); //打印数组第一个元素,不能写成"arr[0]="+arr[0],要注意一下.
           System.out.println(arr);//打印输出数组的首地址.
      /*
      数组的操作:
      1.获取数组中的元素,通常采用遍历,即一个for循环 eg:for(int i=0;i<arr.length;i++),打印arr[i]; //i为数组下标
      2.数组中有一个属性可以直接获取到数组元素的个数: 数组名.length 这个属性很重要,比如可以拿来做判断,用于条件表达式中 eg: if(i!=arr.length-1)
      打印arr[i]和逗号;否则打印arr[i];//打印逗号是为了隔开数据元素.
      3.函数调用数组: function(arr);
      4.数组作为形参: function(int[] arr)
      */
      应用:(1)获取一个数组的最大值和最小值?
      第一种方法:直接定义一个max(min),初始化为数组的第一个元素,再分别比较;  max<arr[i],max=arr[i],return max;
      第二种方法:定义max(min)=0;再利用下标比较  arr[max]<arr[i],max=i,return arr[max].
      Demo0:9.对数组[5,1,6,4,2,8,9]进行排序?
      /*
      第一种方式:
      1.需求:排序
      选择排序思想:先拿arr[0]元素依次与arr[1]~arr[arr.length-1]进行比较,如果arr[0]<(或者>)arr[i],那么进行交换,否则不交换,以此类推,可以考虑到
      最后一个元素不需要交换.
      2.思路:
        第一次第一个元素分别与(假设元素长度为n)后n-1个元素比较;第二次第二个元素分别与后n-2个元素比较,以此类推,是不是类比第一行打印5个*,第二行打
      印4个*,...,是不是尖朝下三角形啊,哦啦,forfor嵌套,且改变左区间(初始化表达式),即y=x.
      */  
      /*
      第二种方式:
      1.需求:排序
      冒泡排序思想:每次将相邻的两个元素进行比较,如果符合条件就进行交换.
      2.思路:
        假设有5,1,6,4,2,8,9;第一趟:5与1比较,交换后为1,5;5与6比较,不交换为1,5,6,...第一趟结束后为1,5,4,2,6,,8,9;第二趟:注意到最(大/小)值到达
      末尾,即9不用在比较了,然后1与5比较,不交换,5与4比较交换,所以第二趟结束为1,4,2,5,6,8,9;以此类推,每i趟只要比较到arr[arr.length-i-1]这个元素
      (i从0开始,少取几个数,就能得出arr.length-i-1这个式子)
      */
      排序方式最快的是希尔排序.
      选择与冒泡排序的基本格式:
      for(int x=0;x<arr.length;x++)
      {
         for(int y=0;y<arr.length;y++)
         {
         }
      }
      注意:不管是选择排序还是冒泡排序,是不是都要进行交换元素位置,将交换操作封装到函数中.
      public static void swap(int[] arr, int a,int b) //只是交换为止,无返回值为void,因为是交换数组中的两个元素,所以要传数组参数,交换两元素
                                                     //要传两个下标
      {
      int temp=arr[a];
      arr[a]=arr[b];
      arr[b]=temp;
      }
      在两个内循环中调用swap(),即swap(arr,x,y);  swap(arr,y,y+1);
      前面学习了数组的获取和排序操作,接下来学习又一操作:
      /*
      数组的查找操作
      1.普通查找,在数组中找一元素的位置,返回下标(位置).
      public static int getIndex(int[] arr,int key) //返回下标为int,在数组中,要传数组形参,查找元素,要传元素形参
      {
      for{int i=0;i<arr.length;i++} //先遍历整个数组
      {
             if(arr[i]==key) //zhaodaoyuansu
             return i; //返回下标
      }
      return -1; //没找到,默认返回-1 
      }
      2.折半查找:效率高,但是前提必须必须必须是一个有序数组.
      思想:
      方法(1)每次利用折中的元素与要查找的元素进行比较,如果相等则返回该中间元素的下标;如果不等则移动
      某一端的下标,继续做折中比较;没有找到该元素的条件是左端下标大于右端下标或者右端小标小于左端下标.
      方法(2)上面的方法循环的条件是折中元素是否等于查找的数,当min>max,循环结束.现在考虑循环条件min<=max就一直循环,判断折中元素是否相等;相等就返回
      mid;不等就改变左或右下标,再求mid的值,继续做循环;否则就是没找到,返回-1.
      */
      Demo0:10.对数组[2,4,5,7,19,32,45]进行查找.
      思考:现在要对上面数组插入数字8,仍保持有序.
      任然利用折半查找,去找数字8的下标,用方法(2),假如数组有元素8,那么返回下标4,将4位置以后的元素顺延,插入数据8;如果没有元素8,原程序返回-1,
      在草稿纸上演算当返回-1时,即min>max,此时min=4,max=3,刚好min=4就是要插入数据的位置,那么就可将return -1;改为return min;//就是数据要插入
      的位置.
      练习:
      1.进制的转换
      eg1:将十进制转变为二进制: 6?
      /*
      1.需求:十->二
      2.思路:取余,拿6%2,打印余数;再拿6/2的商再模2后打印,直到商为0.
      部分代码:
      public static void toBin(int num)
      {while(num>0) {System.out.println(6%2); num=num/2;}}
      */
      eg2:将十进制转变为十六进制: 60?
      /*
      1.需求:十->十六
      2.思路:
        方法(1)我们知道十进制存在内存中为二进制,有32bit,60为0...0011-1100,十六进制对应每4位,所以先让60&15,取出末尾4位存在temp中,判断如果temp大于         9,做数字转化为字母操作;否则不变;再向右移4位,以此类推,循环是在移8次结束.
      public static void toHex(int num)
      {                                                               /*StringBuffer sb=new StringBuffer();//新建一个对象*/
           for(int i=0;i<8;i++)
           {                                                       
                  int temp=num&15;                                                       
                  if(temp>9)
                        System.out.println((char)temp-10+"A");       /*sb.append((char)temp-10+"A");//用容器提供的append()方法往里装*/
                  else 
                        System.out.println(temp);                    /*sb.append(temp);*/
                  num=num>>>4;       
           }
                                                              /*System.out.println(sb.reverse());//利用reverse方法打印正的十六进制*/
      }
         方法(2):对于方法(1),当取出的数超出9,就要减去基数10(对应"A")加上"A",对吧.现在换种方法:
         查表法:将所有数据临时存放在一个表中,建立对应的关系.
               就是建立一个字符数组,当num&15得出temp时,打印 字符数组名[temp]即可,不用再做判断了.
         注:在数组中,常常定义一个指针,作为首下标或末尾下标来使用 格式: int pos=0; int pos=arr.length-1;
            倒着打印 for(int i=arr.length-1;i>=0;i--) {System.out.println(arr[i]+" ");}
         */       
         综合应用:Demo0:11.利用查表法分别定义函数实现10->2,10->8,10->16的转化.
         /*
         思路:建立一个表,用来存储二,八和十六进制数;在建立一个表,用来存储转化的元素;转化封装成一个复用函数,三个函数可以分别调用这个转化函数.
         */
         
        
         
         
         
         
      
      
      
      
      
      
     
     
       

  
  
  
